================ ex00 ================
=> subType poloymorphism: allows objects of different derived types (cat, dog) to be tread uniformly as if they were objects
of the base class (animal) as long as the base class defines the interface as virtual. this type of polymorphism is runtime poly, and we acheive by
doing method overredding (like makeSound() in this exercise), means the program will decide which function to call at runtime, and to achieve that you
need to specify the members as virtual, and this is the core of dynamic dispach.
=> dynamic dispaching: is the process of selecting which implementation of a method or function to call at runtime.

====== how run time polymorphism works ======
=> virtual table and virtual table pointer: when you using virtual keyword on class's method, a vtable is created and holding pointers to these methods.
every class will have a separate vtable and every class will have vfptr that points to that vtable (class' virtual table). 
overall, the vtable for each class will store pointers to method definitions based on class's definitions, means overridding methods will point to their subclass
corresponding definition, and non-overridden will points to the super class definition.
when you do a->makeSound() it's actually a->vptr->makesound().
============

=> const: means the functions dosn't modify the object in it's body, without const it can work on const objects (const Animal * i = new Dog();).
=> why destructor and makesound members or Animal class declared as virtual? : the virtual keyword is what enables the runtime polymorphism, without virtual the call of the members
will be statically bound, means the base class version will called even if the object is a drived one (like new Dog/or Cat).
if you didn't make Destructors as virtual in base, it won't be full cleanup of objects, because it will call only the base one and it won't cleans up the drived parts.

=> the WrongAnimal and WrongCat classes demonstrates lack of polymorphism when you create a base object based on drived class, so when you try to call makeSound it will always call
the WrongAnimal version because the compiler dosn't which one to call, and this the runtime polymorphism, to solve that you can use virtual keyword and make makeSound method as virtual.

===============

=========== difference between static and dynamic binding ========
=> what is binding: is a crucial connection linking a function call to its matching function definition. When a function is called in your code, program control is bound to the memory location where the bind was defined.
as we know we have two main parts of a function Function Definition and Function call.
Different memory locations are used to store these definitions and calls. We need a way to correctly match each call to each functionâ€™s definition because programs often require many functions to run smoothly.
If the binding were not present, then both functions would have mixed up, creating confusion and undesired result.
Connecting a specific function call to its right function definition is called binding. But why is this so important? The advantages of binding are big, and they come in two main types: static and dynamic.
=> static binding (or compile time binding):  Static binding occurs when the connection between a function call and its definition is set when your program is being prepared for running, called Compile Time. 
Some of the advantages of using the Static Binding are as follows:
- Static binding is faster than dynamic binding. The program runs faster because the computer is already aware of all the methods in a class. 
- Programs run more quickly and efficiently because they are faster.
Examples of static binding are: Function overloading and operator overloading.

=> dynamic binding (or run-time binding): is When the connection between a function call and its definition happens while the program is running (after compiling).
Some of the advantages of using dynamic binding are given here:
- The fact that the same function can handle a variety of objects gives it a lot of flexibility.
- It can help make programs smaller and easier to understand.
Examples of dynamic binding is: virtual functions.

============================ Ex01 ==============================
=== shallow copy Vs deep copy ===
in general, creating a copy of an objects means to create an exact replica of the object having the same literal value, data type and resources, and we can achieve that object copying 
using two ways: copy constructor, copy assignement operator.

=> what is shallow copy:  this type of copy, the object is created by simply copying the data of all variables of the original object. this will work fine if no variables are allocateed 
dynamically, if some variables allocated dynamically, then the copied object variable will also referene the same memory allocation, and this will create an ambeguity and runn-time errors
since both objects are refering to the same memory location, and for example if i try to  delete one of object, the other object will be affected and if i try to access to the dynamic allocated variable
i will get a segfault because the first object has destroyed the memory location. so this purpose will not be filled by shallow copy.
=> what is deep copy: an object is also created by copying data of all variables, and it also allocates similar memory resources with the same value to the object. in order to perfom deep copy
we need to explicitly define the copy constructor and assign dynamic memory as well.
=> in our exercise we must apply deep copy on (Brain* ) private attributes of cat and Dog classes and must not be shallow.